#include <concepts>
#include <algorithm>
#include <cmath>
#define __ltr char
#define _420 struct
#define ___A___ auto
#define __C__ constexpr
#define __S__ size_t
#define __T__ template

__C__ __S__ __0 = 66;
__T__<__S__ _a> _420 _the {__ltr _69[_a][_a+1];};
using _the_ = _the<__0>;
__T__<__ltr _B_>
__C__ _the_ __1() {
    _the_ _________;
    for(__S__ _IMAGINARY = 0; _IMAGINARY < __0; _IMAGINARY++) 
    {
        for(__S__ _REAL = 0; _REAL <= __0; _REAL++) 
            _________._69[_IMAGINARY][_REAL] = _IMAGINARY == 0 ? (_REAL < 15 ? '\n' : ' ') : _B_; 
        _________._69[_IMAGINARY][__0] = '\n';
    } 
    return _________;
}
__T__<_the_ _A_>
__C__ _the_ __2() {
    _the_ _________ = _A_;
    __C__ int _1_ = __0 / 2;
    __C__ int _2_ = _1_ - 2;
    __C__ int _3_ = 6*6;
    for(int _B_ = 0; _B_ < __0; _B_++) for(int _C_ = 0; _C_ < __0; _C_++)
        if(((_B_-_1_)*(_B_-_1_) + (_C_-_1_)*(_C_-_1_)) - _2_*_2_ < _3_ && ((_B_-_1_)*(_B_-_1_) + (_C_-_1_)*(_C_-_1_)) - _2_*_2_ > -_3_)
            _________._69[_B_][_C_+1] = '#';
    return _________;
}
__T__<__S__ _D_>
_420 __S_ {
    __C__ __S_(const __ltr (&_A_)[_D_]) 
    {std::copy_n(_A_, _D_, _69);}
    __ltr _69[_D_];
};
__T__<_the_ _A_, __S__ _B_, __S__ _C_, __S__ _E_, __S_<_E_> _D_>
__C__ _the_ __3() {
    _the_ _________ = _A_;
    for(__S__ n = 0; n < _E_-1; n++) _________._69[_B_][n+_C_] = _D_._69[n];
    return _________;
}
__T__<___A___> _420 ____{};
__T__<std::common_with<__S__> _D_> __S__ _();
__C__ _the_ __ = __3<__3<__3<__2<__1<' '>()>(), __0 / 2, __0 / 2, 10, "I Changed">(),__0 / 2 + 1, __0 / 2 + 3, 4, "the">(),__0 / 2 + 2,__0 / 2 + 2,6,"World">(); 
__C__ ___A___ ___ = _<____<__>>();